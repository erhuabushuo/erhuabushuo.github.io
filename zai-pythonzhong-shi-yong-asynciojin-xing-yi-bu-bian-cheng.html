<!doctype html>
<html lang="cn" itemscope itemtype="http://schema.org/Person">
<head>
  <meta charset="utf-8">
  <!-- Site Meta Data -->
  <title>在Python中使用asyncio进行异步编程</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="erhuabushuo(@)gmail.com">

  <link rel="shortcut icon" href="">

  <!-- schema.org -->
  <meta itemprop="name" content="疯人院主任">
  <meta itemprop="image" content="">
  <meta itemprop="description" content="">

  <!-- Style Meta Data -->
  <link rel="stylesheet" href="/theme/css/milligram.css" type="text/css" />
  <link rel="stylesheet" href="/theme/css/custom.css" type="text/css" />

  <!-- Feed Meta Data -->

  <!-- Twitter Feed -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="">
  <meta name="twitter:image" content="">

<meta name="twitter:creator" content="">
<meta name="twitter:url" content="/zai-pythonzhong-shi-yong-asynciojin-xing-yi-bu-bian-cheng.html">
<meta name="twitter:title" content="疯人院主任 ~ 在Python中使用asyncio进行异步编程">
<meta name="twitter:description" content="对于来自JavaScript编码者来说，异步编程不是什么新东西，但对于Python开发者来说，async函数和future(类似JS的promise)可不是那么容易能理解的。 Concurrency vs Parallelism Concurrency和Parallelism听起来一样，但在实际编程里它们有着较大的不同。 想象下你在做饭的时候写书，看起来好像你在同一时间做两件事情，实际你只是在两项事情中相互切换，当你在等水开的时候你就可以去写书，但你切菜时你要暂停写作。这就叫做concurrency。唯一一种使用parallel做这两项工作的办法就是得有两个人，一个人写作，一个人做饭，这就是多核CPU的工作方式了。 为什么asyncio 异步编程允许你在单个线程中并发执行代码。对比多线程处理方式，该方式由你来决定如何由一个任务切换到另一个任务，tasks之间共享数据也更加容易和简单。 def queue_push_back(x): if len(list) &lt; max_size: list.append(x) 如果我们在多线程执行上面的额代码，有可能第二行代码在同一时间被执行，那么同一时间就有两个元素被加入到列表中，那实际列表长度就会操作max_size。 另一个异步编程的好处是内存使用。每次一个新的线程创建，也需要开辟一些新内存用来进行上下文切换。如果使用了异步编程，这在单线程中就不存在该问题。 如何在Python编程async代码 Asyncio包含三个主要组件：coroutine, event ...">

<!-- Facebook Meta Data -->
<meta property="og:title" content="疯人院主任 ~ 在Python中使用asyncio进行异步编程" />
<meta property="og:description" content="对于来自JavaScript编码者来说，异步编程不是什么新东西，但对于Python开发者来说，async函数和future(类似JS的promise)可不是那么容易能理解的。 Concurrency vs Parallelism Concurrency和Parallelism听起来一样，但在实际编程里它们有着较大的不同。 想象下你在做饭的时候写书，看起来好像你在同一时间做两件事情，实际你只是在两项事情中相互切换，当你在等水开的时候你就可以去写书，但你切菜时你要暂停写作。这就叫做concurrency。唯一一种使用parallel做这两项工作的办法就是得有两个人，一个人写作，一个人做饭，这就是多核CPU的工作方式了。 为什么asyncio 异步编程允许你在单个线程中并发执行代码。对比多线程处理方式，该方式由你来决定如何由一个任务切换到另一个任务，tasks之间共享数据也更加容易和简单。 def queue_push_back(x): if len(list) &lt; max_size: list.append(x) 如果我们在多线程执行上面的额代码，有可能第二行代码在同一时间被执行，那么同一时间就有两个元素被加入到列表中，那实际列表长度就会操作max_size。 另一个异步编程的好处是内存使用。每次一个新的线程创建，也需要开辟一些新内存用来进行上下文切换。如果使用了异步编程，这在单线程中就不存在该问题。 如何在Python编程async代码 Asyncio包含三个主要组件：coroutine, event ..." />
<meta property="og:image" content="" />
</head>

<body>
    <div class="container">

    <!-- Navbar -->
      <div class="navbar">
        <ul>
            <div>
                <li>
                    <a href=""><h3>疯人院主任</h3></a>
                </li>
                <li>
                </li>
            </div>
        </ul>
      </div>

  <!-- Sidebar -->
    <sidebar>
        <ul class="static-item">

        </ul>        

        <ul>
                <div class="cat-border">
                <li style="color: #F2F1EF; background-color: #6C7A89;">Categories</li>
                    <li><a href="/category/bluetooth.html">Bluetooth</a></li>
                    <li><a href="/category/flask.html">Flask</a></li>
                    <li><a href="/category/programming.html">Programming</a></li>
                    <li><a href="/category/python.html">Python</a></li>
                    <li><a href="/category/sip.html">SIP</a></li>
                    <li><a href="/category/vue.html">Vue</a></li>
                </div>
        </ul>

            <h2><br/>BLOGROLLS</h2>
            <ul>
                    <li><a href="http://banshenghuo.com/">伴生活</a></li>
                    <li><a href="http://doordu.com/">多度科技</a></li>
            </ul> 
   
        <p> 
                <span>
                    <a href="mailto:erhuabushuo(at)gmail.com" target="_blank">
                        <img class="social-icons-m" src="/theme/images/icons/mail.png">
                    </a>
                </span>
                <span>
                    <a href="http://github.com/erhuabushuo" target="_blank">
                        <img class="social-icons-m" src="/theme/images/icons/github.png">
                    </a>
                </span>
        </p>
        <p>
        </p>
        <p>
        </p>
    </sidebar>
    
    <maincontent>
<h2>
    <a href="/zai-pythonzhong-shi-yong-asynciojin-xing-yi-bu-bian-cheng.html" rel="bookmark" title="Permalink to 在Python中使用asyncio进行异步编程">在Python中使用asyncio进行异步编程</a>
</h2>

<div>
    <b>By: </b><a href="/author/erhuabushuogmailcom.html">erhuabushuo(@)gmail.com</a><b>    On: </b>二 15 一月 2019<br />
    <b>In: </b><a href="/category/python.html" rel="bookmark" title="Permalink to Python">Python</a><br />
    <em><b>Tags: </b>
    </em>
    <hr>
</div>

<div>
    <mainarticle>
    <p>对于来自JavaScript编码者来说，异步编程不是什么新东西，但对于Python开发者来说，async函数和future(类似JS的promise)可不是那么容易能理解的。</p>
<h2>Concurrency vs Parallelism</h2>
<p>Concurrency和Parallelism听起来一样，但在实际编程里它们有着较大的不同。</p>
<p>想象下你在做饭的时候写书，看起来好像你在同一时间做两件事情，实际你只是在两项事情中相互切换，当你在等水开的时候你就可以去写书，但你切菜时你要暂停写作。这就叫做concurrency。唯一一种使用parallel做这两项工作的办法就是得有两个人，一个人写作，一个人做饭，这就是多核CPU的工作方式了。</p>
<p><img alt="alt" src="http://maked.io/content/images/2018/06/concurrency-parallelism.jpeg" /></p>
<h2>为什么asyncio</h2>
<p>异步编程允许你在单个线程中并发执行代码。对比多线程处理方式，该方式由你来决定如何由一个任务切换到另一个任务，tasks之间共享数据也更加容易和简单。</p>
<div class="highlight"><pre>    def queue_push_back(x):
        if len(list) &lt; max_size:
            list.append(x)
</pre></div>


<p>如果我们在多线程执行上面的额代码，有可能第二行代码在同一时间被执行，那么同一时间就有两个元素被加入到列表中，那实际列表长度就会操作<strong>max_size</strong>。</p>
<p>另一个异步编程的好处是内存使用。每次一个新的线程创建，也需要开辟一些新内存用来进行上下文切换。如果使用了异步编程，这在单线程中就不存在该问题。</p>
<h2>如何在Python编程async代码</h2>
<p>Asyncio包含三个主要组件：coroutine, event loop和future</p>
<h3>Coroutine</h3>
<p>coroutine是异步函数，通过在函数定义<strong>def</strong>前使用<strong>async</strong>关键字。</p>
<div class="highlight"><pre>async def my_task(args):
    pass

my_coroutine = my_task(args)
</pre></div>


<p>我们使用了<strong>async</strong>关键字定义了一个函数，该函数并没有执行，返回了一个coroutine对象。</p>
<p>有两种从一个coroutine中获取异步函数的结果</p>
<p>第一种使用<strong>await</strong>关键字，仅只能在async函数中用来等待coroutine结束返回结果</p>
<div class="highlight"><pre>result = await my_task(args)
</pre></div>


<p>第二种是将它加入到event loop中，接下来我们做详尽讨论。</p>
<h2>Event loop</h2>
<p>event loop对象负责执行异步代码以及决定异步函数如何进行切换。在创建了event loop后，我们就可以添加多个coroutines给它，coroutines将会调用了<strong>run_until_complete</strong>或者<strong>run_forever</strong>执行。</p>
<div class="highlight"><pre># create loop
loop = asyncio.new_event_loop()
# add coroutine to the loop
future = loop.create_task(my_coroutine)
# stop the program and execute all coroutine added
# to the loop concurrently
loop.run_until_complete(future)
loop.close()
</pre></div>


<h2>Future</h2>
<p>future类似一个占位对象用来存放异步函数结果，提供函数状态。当coroutine添加到event lop时创建future.有两种方式创建：</p>
<div class="highlight"><pre>future1 = loop.create_task(my_coroutine)
# or
future2 = asyncio.ensure_future(my_coroutine)
</pre></div>


<p>第一个方法是增加一个coroutine到loop中，返回一个<strong>task</strong>，它是future的子类。第二种方法非常类似，它接收一个coroutine，并加入到了默认loop中，唯一的区别是，它也可以接收一个future参数，它将不会做任何事情，直接将futrue返回。</p>
<h2>一个简单的程序</h2>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">my_task</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
    <span class="n">coroutine1</span> <span class="o">=</span> <span class="n">my_task</span><span class="p">()</span>
    <span class="n">coroutine2</span> <span class="o">=</span> <span class="n">my_task</span><span class="p">()</span>
    <span class="n">task1</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coroutine1</span><span class="p">)</span>
    <span class="n">task2</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">coroutine2</span><span class="p">)</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asycnio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">]))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;task1 result:&#39;</span><span class="p">,</span> <span class="n">task1</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;task2 result:&#39;</span><span class="p">,</span> <span class="n">task2</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>就让如你所看见的，我们在执行异步函数前需要先创一个coroutine，然后我们将创建future/task，把它添加到event loop。到现在病没有如何的异步函数被执行，只有当我们调用<strong>loop.run_until_completed</strong>，event loop开始执行所有的通过<strong>loop.createt_task</strong>或者<strong>asyncio.ensure_future</strong>添加的coroutines。<strong>loop.run_until_completed</strong>将会阻塞应用程序，仅当所有的future执行完毕后。在本例中，我们使用<strong>asyncio.wait()</strong>创建future，当传递的所有future执行完后我们就获取到了future所有的结果。</p>
<h2>异步函数</h2>
<p>有一件事需要注意的是在Python中使用<strong>async</strong>声明的函数并不意味着函数会并发执行。如果使用一个普通函数，在前面加入<strong>async</strong>关键字，event loop并不会中断你的函数去执行另一个coroutine。允许event loop进行切换coroutine相当简单，使用<strong>await</strong>关键字就会允许event loop可以切换其他注册到loop中的coroutine。</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">print_numbers_async1</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">print_numbers_async2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">loop1</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
<span class="n">count1_1</span> <span class="o">=</span> <span class="n">loop1</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_numbers_async1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;c1_1&#39;</span><span class="p">))</span>
<span class="n">count2_1</span> <span class="o">=</span> <span class="n">loop1</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_numbers_async1</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;c2_1&#39;</span><span class="p">))</span>
<span class="n">loop1</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">count1_1</span><span class="p">,</span> <span class="n">count2_1</span><span class="p">]))</span>
<span class="n">loop1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">loop2</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
<span class="n">count1_2</span> <span class="o">=</span> <span class="n">loop2</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_numbers_async2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;c1_2&#39;</span><span class="p">))</span>
<span class="n">count2_2</span> <span class="o">=</span> <span class="n">loop2</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_numbers_async2</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&#39;c2_2&#39;</span><span class="p">))</span>
<span class="n">loop2</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">count1_2</span><span class="p">,</span> <span class="n">count2_2</span><span class="p">]))</span>
<span class="n">loop2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>


<p>如果我们执行该代码，我们可以看到loop1将会在c1_1完全执行完后才去执行c2_1。而在loop2每打印五个数值后就会进行切换。</p>
<h2>真实案例</h2>
<p>现在我们Python中最进本的异步编程，现在让我们写一个真实例子，我们从互联网下载一系列页面，并打印出开头三行。</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">aiohttp</span>
<span class="kn">import</span> <span class="nn">asyncio</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">print_preview</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="c"># connect to the server</span>
    <span class="n">async</span> <span class="k">with</span> <span class="n">aiohttp</span><span class="o">.</span><span class="n">ClientSession</span><span class="p">()</span> <span class="k">as</span> <span class="n">session</span><span class="p">:</span>
        <span class="c"># create get request</span>
        <span class="n">async</span> <span class="k">with</span> <span class="n">session</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">as</span> <span class="n">response</span><span class="p">:</span>
            <span class="c"># wait for response</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">await</span> <span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>

            <span class="c"># print first 3 not empty lines</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)))</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="o">*</span><span class="mi">80</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">[:</span><span class="mi">3</span><span class="p">]:</span>
                <span class="k">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">print</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_all_pages</span><span class="p">():</span>
    <span class="n">pages</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">&#39;http://textfiles.com/adventure/amforever.txt&#39;</span><span class="p">,</span>
        <span class="s">&#39;http://textfiles.com/adventure/ballyhoo.txt&#39;</span><span class="p">,</span>
        <span class="s">&#39;http://textfiles.com/adventure/bardstale.txt&#39;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">tasks</span> <span class="o">=</span>  <span class="p">[]</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">pages</span><span class="p">:</span>
        <span class="n">tasks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_preview</span><span class="p">(</span><span class="n">page</span><span class="p">)))</span>

    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">tasks</span><span class="p">))</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">print_all_pages</span><span class="p">()</span>
</pre></div>


<p>这里的代码也很容易理解，我们使用异步函数下载URL，并且打印了前三行。然后我们创建了一个函数用来构建一个页面了列表，交给print_preview去执行，将coroutine加入到loop，把future放到了一个列表中 ，我们执行event loop，在所有coroutine执行完后程序结束。</p>
<h2>异步生成器</h2>
<p>最后我想谈谈的是异步生成器。要实现一个异步生成器相当简单：</p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">prime_generator</span><span class="p">(</span><span class="n">n_prime</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">counter</span> <span class="o">&lt;</span> <span class="n">n_prime</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">prime</span> <span class="o">=</span> <span class="n">await</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prime</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">n</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">check_email</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">limit</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.8</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;1 new email&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;0 new email&#39;</span><span class="p">)</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">async</span> <span class="k">def</span> <span class="nf">print_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">async</span> <span class="k">for</span> <span class="n">prime</span> <span class="ow">in</span> <span class="n">prime_generator</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;new prime number found:&#39;</span><span class="p">,</span> <span class="n">prime</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">new_event_loop</span><span class="p">()</span>
    <span class="n">prime</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">print_prime</span><span class="p">(</span><span class="mi">3000</span><span class="p">))</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">check_email</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">prime</span><span class="p">,</span> <span class="n">email</span><span class="p">]))</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>


<h2>异常处理</h2>
<p>在coroutine内部抛出异常时并不会中断应用程序，如果你没有处理异常的话你将看到类似如下错误：</p>
<div class="highlight"><pre>Task exception was never retrieved
</pre></div>


<p>有两个方法来修正，在获取future结果时捕获异常，或者在future调用exception方法.</p>
<h2>深入了解</h2>
<p>现在你已经了解如何使用asyncio编写并发代码，如果你想深入了解的话，查看官方文档。</p>
    </mainarticle>
</div>
<hr>
        
<div>
        <i>If you found the article helpful, please share or cite the article, and spread the word:</i>
            <p style="margin-top: 2%;">
                <span><a target="_blank" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;" title="Twitter" href="https://twitter.com/share?url=/zai-pythonzhong-shi-yong-asynciojin-xing-yi-bu-bian-cheng.html&text=在Python中使用asyncio进行异步编程&via="><img class="social-icons-a" src="/theme/images/icons/twitter.png"></a></span>
                <span><a target="_blank" title="Facebook" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=500,width=700');return false;" href="https://www.facebook.com/sharer.php?u=/zai-pythonzhong-shi-yong-asynciojin-xing-yi-bu-bian-cheng.html&t=在Python中使用asyncio进行异步编程"><img class="social-icons-a" src="/theme/images/icons/facebook.png"></a></span>

                <a  target="_blank" title="Linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=/zai-pythonzhong-shi-yong-asynciojin-xing-yi-bu-bian-cheng.html&title=在Python中使用asyncio进行异步编程" rel="nofollow" onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img class="social-icons-a" src="/theme/images/icons/linkedin.png"></a>
            </p>
</div>
<hr>
    <p><i>For any feedback or corrections, please write in to: </i><b> erhuabushuo(@)gmail.com </b></p>
        
    </maincontent>

  <!-- Analytics -->

  </div>
</body>

</html>